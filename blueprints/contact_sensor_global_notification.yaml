blueprint:
  name: Contact Sensor Left Open - Global Notification (All Sensors)
  description: |
    Monitor ALL contact sensors with a single automation.

    This blueprint creates one automation that monitors all doors, windows,
    garage doors, and other contact sensors in your home. When any sensor
    is left open too long, you get a notification.

    Features:
    - Monitors ALL contact sensors automatically
    - New sensors work immediately (no configuration needed)
    - Auto-clear when sensor closes
    - Optional critical iOS notifications
    - Optional repeat reminders
    - Customizable messages and actions

  domain: automation

  input:
    # --- Global Settings ---
    delay_minutes:
      name: Delay (minutes)
      description: How long a sensor must be open before alerting
      default: 10
      selector:
        number:
          min: 1
          max: 1440
          unit_of_measurement: minutes
          mode: slider

    critical_notification:
      name: Critical Notification (iOS)
      description: Use critical notification to bypass Do Not Disturb mode
      default: false
      selector:
        boolean:

    # --- Notification Settings ---
    notify_service:
      name: Notification Service
      description: The notification service to use (e.g., notify.mobile_app_iphone)
      selector:
        text:

    notification_title:
      name: Notification Title
      description: "Variables: {{sensor_name}}, {{area}}, {{delay_minutes}}"
      default: "{{sensor_name}} Left Open"
      selector:
        text:

    notification_message:
      name: Notification Message
      description: "Variables: {{sensor_name}}, {{area}}, {{delay_minutes}}, {{time_open}}"
      default: "{{sensor_name}} has been open for {{time_open}}"
      selector:
        text:

    # --- Repeat Notifications ---
    repeat_enabled:
      name: Enable Repeat Notifications
      description: Send repeated reminders while sensor remains open
      default: false
      selector:
        boolean:

    repeat_interval:
      name: Repeat Interval (minutes)
      description: How often to repeat notifications (only if repeat is enabled)
      default: 30
      selector:
        number:
          min: 1
          max: 1440
          unit_of_measurement: minutes
          mode: slider

    # --- Additional Conditions ---
    additional_conditions:
      name: Additional Conditions
      description: Extra conditions that must be true (e.g., someone is home)
      default: []
      selector:
        condition:

    # --- Custom Actions ---
    custom_actions_on_open:
      name: Custom Actions (On Open Alert)
      description: Additional actions to run when the open alert triggers
      default: []
      selector:
        action:

    custom_actions_on_close:
      name: Custom Actions (On Close)
      description: Additional actions to run when any sensor closes
      default: []
      selector:
        action:

# Define the automation behavior
mode: parallel
max: 50
max_exceeded: silent

variables:
  # Store inputs as variables
  delay_minutes_input: !input delay_minutes
  critical_input: !input critical_notification
  notify_service_input: !input notify_service
  notification_title_input: !input notification_title
  notification_message_input: !input notification_message
  repeat_enabled_input: !input repeat_enabled
  repeat_interval_input: !input repeat_interval

trigger:
  # Trigger on ANY binary_sensor state change
  - platform: state
    entity_id: binary_sensor
    to:
      - "on"
      - "off"

condition:
  - and:
      # Only proceed if this is a contact sensor
      - condition: template
        value_template: >
          {% set device_class = state_attr(trigger.entity_id, 'device_class') %}
          {{ device_class in ['door', 'window', 'opening', 'garage_door'] }}

      # Additional user-defined conditions
      - condition: !input additional_conditions

action:
  - variables:
      # Extract sensor information
      sensor_name: "{{ state_attr(trigger.entity_id, 'friendly_name') }}"
      area: "{{ area_name(trigger.entity_id) | default('Unknown', true) }}"
      sensor_entity_id: "{{ trigger.entity_id }}"

      # Prepare notification data
      notification_data: >
        {% set data = namespace(result={}) %}
        {% if critical_input %}
          {% set data.result = {'push': {'sound': {'name': 'default', 'critical': 1, 'volume': 1.0}}} %}
        {% endif %}
        {{ data.result }}

  - choose:
      # --- SENSOR CLOSED: Clear notification and run custom actions ---
      - conditions:
          - condition: template
            value_template: "{{ trigger.to_state.state == 'off' }}"
        sequence:
          # Clear the notification
          - service: "{{ notify_service_input }}"
            data:
              message: "clear_notification"
              data:
                tag: "contact_sensor_{{ sensor_entity_id | replace('.', '_') }}"

          # Run custom close actions
          - choose: []
            default: !input custom_actions_on_close

    # --- SENSOR OPEN: Send notification(s) ---
    default:
      # Wait for the configured delay
      - delay:
          minutes: "{{ delay_minutes_input | int }}"

      # Check if still open after delay
      - condition: template
        value_template: "{{ is_state(sensor_entity_id, 'on') }}"

      - variables:
          # Calculate how long the sensor has been open
          delay_minutes: "{{ delay_minutes_input }}"
          time_open: >
            {% set opened_at = states[sensor_entity_id].last_changed %}
            {% set duration = now() - opened_at %}
            {% set hours = duration.total_seconds() // 3600 %}
            {% set minutes = (duration.total_seconds() % 3600) // 60 %}
            {% if hours > 0 %}
              {{ hours | int }} hour{{ 's' if hours > 1 else '' }}
              and {{ minutes | int }} minute{{ 's' if minutes != 1 else '' }}
            {% else %}
              {{ minutes | int }} minute{{ 's' if minutes != 1 else '' }}
            {% endif %}

      # Send the initial notification
      - service: "{{ notify_service_input }}"
        data:
          title: "{{ notification_title_input }}"
          message: "{{ notification_message_input }}"
          data: >
            {{ dict(notification_data, **{'tag': 'contact_sensor_' + (sensor_entity_id | replace('.', '_'))}) }}

      # Run custom open actions
      - choose: []
        default: !input custom_actions_on_open

      # Repeat notifications if enabled
      - if:
          - condition: template
            value_template: "{{ repeat_enabled_input }}"
        then:
          - repeat:
              while:
                - condition: template
                  value_template: "{{ is_state(sensor_entity_id, 'on') }}"
              sequence:
                - delay:
                    minutes: "{{ repeat_interval_input | int }}"

                # Check if still open before sending repeat notification
                - if:
                    - condition: template
                      value_template: "{{ is_state(sensor_entity_id, 'on') }}"
                  then:
                    - variables:
                        # Recalculate time open for repeat notification
                        time_open: >
                          {% set opened_at = states[sensor_entity_id].last_changed %}
                          {% set duration = now() - opened_at %}
                          {% set hours = duration.total_seconds() // 3600 %}
                          {% set minutes = (duration.total_seconds() % 3600) // 60 %}
                          {% if hours > 0 %}
                            {{ hours | int }} hour{{ 's' if hours > 1 else '' }}
                            and {{ minutes | int }} minute{{ 's' if minutes != 1 else '' }}
                          {% else %}
                            {{ minutes | int }} minute{{ 's' if minutes != 1 else '' }}
                          {% endif %}

                    - service: "{{ notify_service_input }}"
                      data:
                        title: "{{ notification_title_input }}"
                        message: "{{ notification_message_input }}"
                        data: >
                          {{ dict(notification_data, **{'tag': 'contact_sensor_' + (sensor_entity_id | replace('.', '_'))}) }}
